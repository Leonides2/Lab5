<!DOCTYPE html>
<html>

<head>
  <title>UNA-CHAT</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="img/favicon.svg">
</head>

<body>
  <ul id="messages">
    <li>Bienvenido al chat. Escribe un mensaje para comenzar.</li>
  </ul>

  <form action="" id="chatForm">
    <input type="text" id="nombre" autocomplete="off" placeholder="Tu nombre (opcional)" />
    <input type="text" id="m" autocomplete="off" placeholder="Escribe un mensaje o pega una URL de imagen/video" />
    <button type="submit">Enviar</button>
  </form>

  <script src="https://cdn.socket.io/4.7.2/socket.io.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script>
    // Variables globales
    let colorHexTxt = "";
    let isTyping = false;
    let typingTimer;
    const TYPING_TIMER_LENGTH = 1000; // 1 segundo

    // Genera colores aleatorios en hexadecimal
    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    // Escapar HTML para prevenir XSS
    function escapeHtml(unsafe) {
      if (!unsafe) return '';
      return unsafe
        .toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Función para hacer scroll al final del chat
    function scrollToBottom() {
      const messages = document.getElementById('messages');
      if (messages) {
        messages.scrollTop = messages.scrollHeight;
      }
    }

    function sanitizeMessage(message) {
      if (message.toLowerCase().includes('<script>')) {
        return escapeHtml(message);
      }
      return message;
    }

    async function getProfile() {
      const data = await fetch('/profile')
      if (data.status === 401) {
        return null;
      }
      const json = await data.json();
      return json;
    }

    // Inicialización cuando el DOM esté listo
    $(function () {
      // Conectar al servidor
      const socket = io();

      // Generar un color aleatorio para el usuario
      if (!colorHexTxt) {
        colorHexTxt = getRandomColor();
      }

      // Configurar el formulario
      $('form').submit(function (e) {
        e.preventDefault();

        const nombreTxt = $('#nombre').val() || 'Anónimo';
        const mensajeTxt = $('#m').val();

        if (mensajeTxt.trim() === '') return false;

        // Enviar mensaje al servidor
        socket.emit('chat message', {
          nombre: nombreTxt,
          mensaje: mensajeTxt,
          color: colorHexTxt,
          timestamp: new Date().toISOString()
        });

        // Limpiar el campo de mensaje
        $('#m').val('').focus();

        // Desactivar estado de escritura
        isTyping = false;
        socket.emit('stop typing');

        return false;
      });

      // Detectar cuando el usuario está escribiendo
      $('#m').on('input', function () {
        const nombreTxt = $('#nombre').val() || 'Alguien';
        const message = $(this).val().trim();

        // Si hay texto y no estábamos escribiendo, notificar que empezamos a escribir
        if (message && !isTyping) {
          isTyping = true;
          socket.emit('typing', { username: nombreTxt });
        }
        // Si no hay texto y estábamos escribiendo, notificar que paramos
        else if (!message && isTyping) {
          isTyping = false;
          socket.emit('stop typing');
        }

        // Reiniciar el temporizador solo si hay texto
        clearTimeout(typingTimer);
        if (message) {
          typingTimer = setTimeout(() => {
            if (isTyping) {
              isTyping = false;
              socket.emit('stop typing');
            }
          }, TYPING_TIMER_LENGTH);
        }
      });

      // Detectar cuando el usuario deja de escribir
      $('#m').on('blur', function () {
        if (isTyping) {
          isTyping = false;
          socket.emit('stop typing');
        }
      });



      // Evento cuando se recibe un mensaje
      socket.on('chat message', function (msg) {
        try {
          const msgJson = typeof msg === 'string' ? JSON.parse(msg) : msg;
          const time = new Date(msgJson.timestamp).toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit'
          });
          
          const mensaje  = msgJson.mensaje;
          // Mostrar el mensaje directamente (el procesamiento está en el backend)
          $('#messages').append($('<li>').html(`
            <div>
              <b style="color: ${msgJson.color}">${escapeHtml(msgJson.nombre)}</b>
              <span class="message-time">${time}</span>
            </div>
           <div>${sanitizeMessage(mensaje) || ''}
          `));

          scrollToBottom();

        } catch (e) {
          console.error('Error al procesar el mensaje:', e);
        }
      });

      // Evento cuando alguien está escribiendo
      socket.on('typing', function (data) {
        $('.typing-indicator').remove();
        if (data.username !== ($('#nombre').val() || 'Anónimo')) {
          $('#messages').append($('<li class="typing-indicator">').text(`${data.username} está escribiendo...`));
          scrollToBottom();
        }
      });

      // Evento cuando alguien deja de escribir
      socket.on('stop typing', function () {
        $('.typing-indicator').remove();
      });

      // Enfocar el campo de mensaje al cargar
      $('#m').focus();
    });

    $(document).ready(async function() {
      const profileData = await getProfile();
      if (profileData) {
        $('#nombre').val(profileData.name);
        $('#nombre').attr('disabled', true);
      }
    });
  </script>
</body>

</html>