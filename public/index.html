<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>UNA-CHAT</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="img/favicon.svg">
</head>

<body>
  <header>
    <div class="header-left">
    <img src="img/favicon.svg" alt="favicon" class="favicon">
    <h1>UNA-CHAT</h1>
    </div>
    
    <div id="authButtons">
      <div id="profile"></div>
      <button id="loginButton" class="btn">Iniciar sesión</button>
      <button id="logoutButton" class="btn" style="display: none;">Cerrar sesión</button>
    </div>
  </header>

  <main>
    <ul id="messages">
      <li>Bienvenido al chat. Escribe un mensaje para comenzar.</li>
    </ul>
  </main>

  <footer>
    <form action="" id="chatForm">
      <input type="text" id="nombre" autocomplete="off" placeholder="Tu nombre (opcional)" />
      <input type="text" id="m" autocomplete="off" placeholder="Escribe un mensaje o pega una URL de imagen/video" />
      <button type="submit">Enviar</button>
    </form>
  </footer>

  <script src="https://cdn.socket.io/4.7.2/socket.io.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script>
    // Variables globales
    let colorHexTxt = "";
    let isTyping = false;
    let typingTimer;
    const TYPING_TIMER_LENGTH = 1000; // 1 segundo

    // Genera colores aleatorios en hexadecimal
    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    // Escapar HTML para prevenir XSS
    function escapeHtml(unsafe) {
      if (!unsafe) return '';
      return unsafe
        .toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Función para hacer scroll al final del chat
    function scrollToBottom() {
      const messages = document.getElementById('messages');
      if (messages) {
        messages.scrollTop = messages.scrollHeight;
      }
    }

    function sanitizeMessage(message) {
      if (message.toLowerCase().includes('<script>')) {
        return escapeHtml(message);
      }
      return message;
    }

    async function getProfile() {
      try {
        const response = await fetch('/profile', {
          credentials: 'same-origin'
        });
        
        if (response.status === 401) {
          return null;
        }
        
        const json = await response.json();
        
        if (json.authenticated === false) {
          return null;
        }
        
        return json;
      } catch (error) {
        console.error('Error al obtener perfil:', error);
        return null;
      }
    }

    // Inicialización cuando el DOM esté listo
    $(function () {
      // Conectar al servidor
      const socket = io();

      // Generar un color aleatorio para el usuario
      if (!colorHexTxt) {
        colorHexTxt = getRandomColor();
      }

      // Configurar el formulario
      $('form').submit(function (e) {
        e.preventDefault();

        const nombreTxt = $('#nombre').val() || 'Anónimo';
        const mensajeTxt = $('#m').val();

        if (mensajeTxt.trim() === '') return false;

        // Enviar mensaje al servidor
        socket.emit('chat message', {
          nombre: nombreTxt,
          mensaje: mensajeTxt,
          color: colorHexTxt,
          timestamp: new Date().toISOString()
        });

        // Limpiar el campo de mensaje
        $('#m').val('').focus();

        // Desactivar estado de escritura
        isTyping = false;
        socket.emit('stop typing');

        return false;
      });

      // Detectar cuando el usuario está escribiendo
      $('#m').on('input', function () {
        const nombreTxt = $('#nombre').val() || 'Alguien';
        const message = $(this).val().trim();

        // Si hay texto y no estábamos escribiendo, notificar que empezamos a escribir
        if (message && !isTyping) {
          isTyping = true;
          socket.emit('typing', { username: nombreTxt });
        }
        // Si no hay texto y estábamos escribiendo, notificar que paramos
        else if (!message && isTyping) {
          isTyping = false;
          socket.emit('stop typing');
        }

        // Reiniciar el temporizador solo si hay texto
        clearTimeout(typingTimer);
        if (message) {
          typingTimer = setTimeout(() => {
            if (isTyping) {
              isTyping = false;
              socket.emit('stop typing');
            }
          }, TYPING_TIMER_LENGTH);
        }
      });

      // Detectar cuando el usuario deja de escribir
      $('#m').on('blur', function () {
        if (isTyping) {
          isTyping = false;
          socket.emit('stop typing');
        }
      });



      // Evento cuando se recibe un mensaje
      socket.on('chat message', function (msg) {
        try {
          const msgJson = typeof msg === 'string' ? JSON.parse(msg) : msg;
          const time = new Date(msgJson.timestamp).toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit'
          });
          
          const mensaje  = msgJson.mensaje;
          // Mostrar el mensaje directamente (el procesamiento está en el backend)
          $('#messages').append($('<li>').html(`
            <div>
              <b style="color: ${msgJson.color}">${escapeHtml(msgJson.nombre)}</b>
              <span class="message-time">${time}</span>
            </div>
           <div>${sanitizeMessage(mensaje) || ''}
          `));

          scrollToBottom();

        } catch (e) {
          console.error('Error al procesar el mensaje:', e);
        }
      });

      // Evento cuando alguien está escribiendo
      socket.on('typing', function (data) {
        $('.typing-indicator').remove();
        if (data.username !== ($('#nombre').val() || 'Anónimo')) {
          $('#messages').append($('<li class="typing-indicator">').text(`${data.username} está escribiendo...`));
          scrollToBottom();
        }
      });

      // Evento cuando alguien deja de escribir
      socket.on('stop typing', function () {
        $('.typing-indicator').remove();
      });

      // Enfocar el campo de mensaje al cargar
      $('#m').focus();
    });

    $('#loginButton').click(function() {
      window.location.href = '/login';
    });

    $('#logoutButton').click(function() {
      window.location.href = '/logout';
    });

    $(document).ready(async function() {
      const profileData = await getProfile();
      if (profileData) {
        $('#nombre').val(profileData.name);
        $('#nombre').attr('disabled', true);
        $('#loginButton').hide();
        $('#logoutButton').show();
        $('#profile').html(`
          <img class="profile-picture" src="${profileData.picture}" alt="profile-pic">
          <span>${profileData.name}</span>
        `);
      }
    });
  </script>
</body>

</html>